@startuml

class IDbContextFactory {
    +create() : Promise<IDbContext>
}

class IDbContext {
    - unitOfWork : IUnitOfWork | null
    - unitOfWorkFactory : IUnitOfWorkFactory
    - mediaBorrowingRepository : IMediaBorrowingRepository | null
    - userRepository : IUserRepository | null
    - mediaInventoryRepository : IMediaInventoryRepository | null
    - mediaBorrowingConfigRepository : IMediaBorrowingConfigRepository | null
    - branchRepository : IBranchRepository | null
    + getMediaBorrowingRepository() : Promise<IMediaBorrowingRepository>
    + getUserRepository() : Promise<IUserRepository>
    + getMediaInventoryRepository() : Promise<IMediaInventoryRepository>
    + getMediaBorrowingConfigRepository() : Promise<IMediaBorrowingConfigRepository>
    + getBranchRepository() : Promise<IBranchRepository>
    + commit() : Promise<void>
    + rollback() : Promise<void>
    + isClosed() : boolean
}

IDbContextFactory --> IDbContext : create()

interface IMediaBorrowingLogic {
    +BorrowMediaItem(mediaBorrowingRecord : MediaBorrowingRecord) : Promise<Message<boolean>>
}

class MediaBorrowingLogic {
    +BorrowMediaItem(mediaBorrowingRecord : MediaBorrowingRecord) : Promise<Message<boolean>>
    +verifyMediaItemIsAvailable(mediaId: number, branchId : number, result : Message<boolean>)
    +validateBorrowingDates(startDate : Date, endDate : Date, branchId: number ,result : Message<boolean>)
    +validateUserEligibility(mediaBorrowingRecord : MediaBorrowingRecord, result : Message<boolean>)
    +rejectIfUserIsAlreadyBorrowingMediaItem(mediaBorrowingRecord : MediaBorrowingRecord, dbContext : IDbContext, result: Message<boolean>)
}

MediaBorrowingLogic --|> IMediaBorrowingLogic : <|.. 

interface IUserEligibilityLogic {
    +isUserEligibleToBorrowMediaItemAtBranch(userId : number, mediaId : number, branchId : number) : Promise<Message<boolean>>
}

class UserEligibilityLogic {
    +isUserEligibleToBorrowMediaItemAtBranch(userId : number, mediaId : number, branchId : number) : Promise<Message<boolean>>
    +getUser(userId : number, dbContext : IDbContext) : Promise<User>
    +verifyUserIsInSameCityAsBranch(userLocationId : number, branchId : number, dbContext : IDbContext, result : Message<boolean>) : Promise<void>
}

UserEligibilityLogic --|> IUserEligibilityLogic : <|.. 
MediaBorrowingLogic ..> UserEligibilityLogic : uses

interface IMediaBorrowingDateValidator {
    +validateBorrowingDates(dateValiationRequest : BorrowingDateValidationRequest) : Promise<Message<boolean>>
}

class MediaBorrowingDateValidator {
    +validateBorrowingDates(borrowingDateValidationRequest : BorrowingDateValidationRequest) : Promise<Message<boolean>>
    +validateDateRangeAgainstMinimumBorrowingDuration(startDate : Date, endDate : Date, result : Message<boolean>)
    +validateDateRangeAgainstBranchOpeningHours(startDate : Date, endDate : Date, branchId : number, dbContext : IDbContext, result : Message<boolean>)
    +validateBorrowingDurationAgainstMaximum(borrowingDateValidationRequest : BorrowingDateValidationRequest, dbContext : IDbContext, result : Message<boolean>)
}

MediaBorrowingDateValidator --|> IMediaBorrowingDateValidator : <|.. 
MediaBorrowingLogic ..> MediaBorrowingDateValidator : uses

interface IMediaInventoryLogic {
    +isMediaItemAvailableAtBranch(mediaId : number, branchId : number) : Promise<Message<boolean>>
    +incrementMediaItemAvailabilityAtBranch(mediaId : number, branchId : number) : Promise<Message<boolean>>
    +decrementMediaItemAvailabilityAtBranch(mediaId : number, branchId : number) : Promise<Message<boolean>>
}

class MediaInventoryLogic {
    +isMediaItemAvailableAtBranch(mediaId : number, branchId : number) : Promise<Message<boolean>>
    +incrementMediaItemAvailabilityAtBranch(mediaId : number, branchId : number) : Promise<Message<boolean>>
    +decrementMediaItemAvailabilityAtBranch(mediaId : number, branchId : number) : Promise<Message<boolean>>
    +getMediaItem(mediaId : number, branchId : number, dbContext : IDbContext) : Promise<MediaInventoryRecord>
    +updateMediaItem(mediaInventoryRecord : MediaInventoryRecord, dbContext : IDbContext)
}

MediaInventoryLogic --|> IMediaInventoryLogic : <|.. 
MediaBorrowingLogic ..> MediaInventoryLogic : uses

interface IMediaReturnLogic {
    +returnMediaItem(mediaId : number, branchId : number) : Promise<Message<boolean>>
}

class MediaReturnLogic {
    +returnMediaItem(mediaId : number, branchId : number) : Promise<Message<boolean>>
}

MediaReturnLogic --|> IMediaReturnLogic : <|.. 

interface IMediaRenewalLogic {
    +renewMediaItem(mediaRenewalRequest : MediaRenewalRequest) : Promise<Message<boolean>>
}

class MediaRenewalLogic {
    +renewMediaItem(mediaRenewalRequest : MediaRenewalRequest) : Promise<Message<boolean>>
    +verifyRenewalLimitIsNotExceeded(renewals : number, branchId : number, dbContext : IDbContext, result : Message<boolean>)
    +validateRenewedEndDate(borrowingDateValidationRequest : BorrowingDateValidationRequest, result : Message<boolean>)
}

MediaRenewalLogic --|> IMediaRenewalLogic : <|.. 
MediaRenewalLogic ..> MediaBorrowingDateValidator : uses

MediaBorrowingLogic ..> IDbContext : uses getMediaBorrowingRepository()
MediaBorrowingDateValidator ..> IDbContext : uses getMediaBorrowingConfigRepository()
MediaRenewalLogic ..> IDbContext : uses getMediaBorrowingRepository(), getMediaBorrowingConfigRepository()
MediaReturnLogic ..> IDbContext : uses getMediaBorrowingRepository()
MediaInventoryLogic ..> IDbContext : uses getMediaInventoryRepository()

class Message<T> {
    +value: T
    +errors: Error[]
    +addError(error: Error) : void
    +addErrorsFromMessage(rmessage : Message<any>) : void
    +hasErrors() : boolean
}

note right of Message
    used for message passing
end note

@enduml